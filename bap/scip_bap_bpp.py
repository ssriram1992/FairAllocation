from pyscipopt import Model, Pricer, SCIP_RESULT, SCIP_PARAMSETTING, quicksum, Branchrule


# This is the branching object, and the user must define some of the functions below
class CutBranching(Branchrule):
    def __init__(self, model, variables):
        self.model = model
        self.variables = variables # We can add all the parameeters we need, such as the variables
        
    def branchfree(self):
        print('==========> Branching: Free memory')
        pass
    
    def branchinit(self):
        print('==========> Branching: Initialize')
        pass
    
    def branchexit(self):
        print('==========> Branching: Deinitialize')
        pass
     
    def branchinitsol(self):
        print('==========> Branching: Start branch and bound')
        pass
     
    def branchexitsol(self):
        print('==========> Branching: Stop branch and bound')
        pass

    # Branching rule: Executes branching rule for fractional LP solution
    # This function must be defined by the user
    def branchexeclp(self, allowaddcons):
        self.choice = self.model.getLPBranchCands()[0][0]
        down, eq, up = self.model.branchVar(self.choice)
        print('==========> Branching on', self.choice)
        return {"result": SCIP_RESULT.BRANCHED}

    # Optional: Executes branching rule for external branching candidates
    def branchexecext(self, alloaddcons):
        pass

    # Optional: Executes branching rule for not completely fixed pseudo solution
    def branchexecps(self, alloaddcons):
        pass
    

# This is the pricer object, and the user must define some of the functions below
class CutPricer(Pricer):
    def __init__(self):
        self.data = {}

    # Initialisation function for the variable pricer to retrieve the transformed constraints of the problem
    # Note: What is a transformed constraint?
    def pricerinit(self):
        for i, c in enumerate(self.data['cons']):
            self.data['cons'][i] = self.model.getTransformedCons(c)
        
    # The reduced cost function for the variable pricer
    def pricerredcost(self):
        # Retrieving the dual solutions
        dualSolutions = []
        for i, c in enumerate(self.data['cons']):
            dualSolutions.append(self.model.getDualsolLinear(c))

        # Building a MIP to solve the subproblem
        subMIP = Model("CuttingStock-Sub")
        subMIP.setPresolve(SCIP_PARAMSETTING.OFF)
        subMIP.hideOutput()

        # Variables for subMIP
        cutWidthVars = []
        varNames = []
        varBaseName = "CutWidth"
        for i in range(len(dualSolutions)):
            varNames.append(varBaseName + "_" + str(i))
            cutWidthVars.append(subMIP.addVar(varNames[i], vtype = "I", obj = -1.0 * dualSolutions[i]))

        # Adding the knapsack constraint (pricing problem constraints)
        knapsackCons = subMIP.addCons(
            quicksum(w*v for (w,v) in zip(self.data['widths'], cutWidthVars)) <= self.data['rollLength'])

        # Solving the subMIP to generate the most negative reduced cost pattern
        subMIP.optimize()

        # Adding a new column to the master problem
        objval = 1 + subMIP.getObjVal()
        if objval < -1e-08:
            currentNumVar = len(self.data['var'])

            # A new variable is created for the new pattern: the pricedVar flag must be set to True (this tells the master problem that this variable was generated by the pricing problem)
            newVar = self.model.addVar("NewPattern_" + str(currentNumVar), vtype="I", obj=1.0, pricedVar=True)

            # Add the new variable to the constraints of the master problem
            # The new pattern is created, and the demand constraints of the master problem are updated here, to take into account this new variable
            newPattern = []
            for i, c in enumerate(self.data['cons']):
                coeff = round(subMIP.getVal(cutWidthVars[i]))
                self.model.addConsCoeff(c, newVar, coeff)
                newPattern.append(coeff)

            # Storing the new variable in the pricer data.
            self.data['patterns'].append(newPattern)
            self.data['var'].append(newVar)
            print(f'==========> Generated a column: NewPattern_{currentNumVar}')

        return {'result':SCIP_RESULT.SUCCESS}


def cuttingstock():
    # Master problem
    s = Model("CuttingStock")
    s.setPresolve(0)

    # Pricing problem
    pricer = CutPricer()
    s.includePricer(pricer, "CuttingStockPricer", "Pricer to identify new cutting stock patterns")

    # Problem data
    widths = [14, 31, 36, 45]
    demand = [211, 395, 610, 97]
    rollLength = 100

    # MP variables
    cutPatternVars = [] # List of int vars: Number of times variable i (pattern i) is used
    varNames = [] # List of strings: Names of the variables
    varBaseName = "Pattern"
    patterns = [] # List of patterns (a pattern is a list of integers: pattern[i] is how many times weight i is in that pattern)

    # Initial columns: Variables
    for i in range(len(widths)):
        varNames.append(varBaseName + "_" + str(i))
        cutPatternVars.append(s.addVar(varNames[i], obj = 1.0, vtype = "I"))

    # Demand constraints
    demandCons = [] # List of constraints: The demand must be satisfied (these constraints are updated inside of the pricing problem, when a new pattern/variable is generated)
    for i in range(len(widths)):
        numWidthsPerRoll = float(int(rollLength/widths[i]))
        
        # The modifiable flag must be set to True (this tells the msater problem that the pricing problem will automatically modify these constraints to take into account newly generated columns)
        # Note: What does the separate flag do?
        demandCons.append(s.addCons(numWidthsPerRoll*cutPatternVars[i] >= demand[i], separate = False, modifiable = True))
        # Initial columns: Patterns
        newPattern = [0]*len(widths)
        newPattern[i] = numWidthsPerRoll
        patterns.append(newPattern)

    # Setting the pricer_data for use in the init and redcost functions
    pricer.data['var'] = cutPatternVars # List of int vars: Number of tiles variable/pattern i is used
    pricer.data['cons'] = demandCons # List of constraints (demand)
    pricer.data['widths'] = widths # List of integers
    pricer.data['demand'] = demand # List of integers
    pricer.data['rollLength'] = rollLength # Capacity: integer
    pricer.data['patterns'] = patterns # List of patterns (pattern: list of integer)

    # Add the branching rule to the MP
    branchrule = CutBranching(s, cutPatternVars)
    s.includeBranchrule(branchrule, '', '', priority=10000000, maxdepth=999, maxbounddist=1.0)
    
    # solve problem
    s.optimize() # This here solves the MP, using the PP and the branching rule

    # print original data
    printWidths = '\t'.join(str(e) for e in widths)
    print('\nInput Data')
    print('==========')
    print('Roll Length:', rollLength)
    print('Widths:\t', printWidths)
    print('Demand:\t', '\t'.join(str(e) for e in demand))

    # print solution
    widthOutput = [0]*len(widths)
    print('\nResult')
    print('======')
    print('\t\tSol Value', '\tWidths\t', printWidths)
    for i in range(len(pricer.data['var'])):
        rollUsage = 0
        solValue = s.getVal(pricer.data['var'][i])
        if solValue > 0:
            outline = 'Pattern_' + str(i) + ':\t' + str(solValue) + '\t\tCuts:\t '
            for j in range(len(widths)):
                rollUsage += pricer.data['patterns'][i][j]*widths[j]
                widthOutput[j] += pricer.data['patterns'][i][j]*solValue
                outline += str(pricer.data['patterns'][i][j]) + '\t'
            outline += 'Usage:' + str(rollUsage)
            print(outline)

    print('\t\t\tTotal Output:\t', '\t'.join(str(e) for e in widthOutput))

    
if __name__ == '__main__':
    cuttingstock()
